#!/usr/bin/env bash
set -euo pipefail

message="Auto-Submission"
tags=""

show_help() {
  cat <<EOF
Usage: $(basename "$0") [options]

Options:
  -m, --message <msg>   Commit message (default: "Auto-Submission")
  -t, --tags <tag>      Tag to push (e.g. "v*" for auto-increment)
  -h, --help            Show this help message and exit

Examples:
  $(basename "$0") -m "fix: bug correction"
  $(basename "$0") -m "release" -t "v*"
  $(basename "$0") -t "build42"
EOF
}

# ---- Prevent leftover Git locks
rm -f "$(git rev-parse --show-toplevel)/.git/index.lock" 2>/dev/null || true

# ---- Parse options with GNU getopt if available, otherwise fallback to getopts
if command -v getopt >/dev/null 2>&1 && getopt --test >/dev/null 2>&1; then
  # GNU getopt: supports long options
  parsed_args=$(getopt -o m:t:h -l message:,tags:,help -n "$(basename "$0")" -- "$@") || {
    echo "Error parsing options." >&2
    exit 2
  }
  eval set -- "$parsed_args"
  while true; do
    case "${1:-}" in
      -m|--message) message="${2:-}"; shift 2 ;;
      -t|--tags)    tags="${2:-}";    shift 2 ;;
      -h|--help)    show_help; exit 0 ;;
      --) shift; break ;;
      *)  break ;;
    esac
  done
else
  # Fallback: basic getopts support
  args=()
  while (( "$#" )); do
    case "$1" in
      --message) shift; args+=("-m" "${1:-}");;
      --tags)    shift; args+=("-t" "${1:-}");;
      --help)    args+=("-h");;
      *)         args+=("$1");;
    esac
    shift || true
  done
  set -- "${args[@]}"
  while getopts ":m:t:h" opt; do
    case "$opt" in
      m) message="$OPTARG" ;;
      t) tags="$OPTARG" ;;
      h) show_help; exit 0 ;;
      \?) echo "Invalid option: -$OPTARG" >&2; exit 2 ;;
      :)  echo "Option -$OPTARG requires an argument." >&2; exit 2 ;;
    esac
  done
  shift $((OPTIND-1))
fi

# ---- Git add / commit
git add -A
git status
git commit -m "$message" || {
  exit 1
}

# ---- Push & tagging (with increment if suffix '*')
if [[ -z "${tags}" ]]; then
  git push
else
  if [[ "$tags" == *"*"* ]]; then
    tag_prefix="${tags//\*/}"

    last_tag="$(git tag --list "${tag_prefix}"'*' | sort -V | tail -n 1 || true)"

    if [[ -z "$last_tag" ]]; then
      new_tag="${tag_prefix}1"
    else
      last_number="$(printf '%s' "$last_tag" | sed "s/^${tag_prefix}//")"
      if [[ "$last_number" =~ ^[0-9]+$ ]]; then
        new_number=$(( last_number + 1 ))
      else
        new_number=1
      fi
      new_tag="${tag_prefix}${new_number}"
    fi
  else
    new_tag="$tags"
  fi

  git tag -a "$new_tag" -m "$new_tag"
  git push --follow-tags
fi

exit 0

